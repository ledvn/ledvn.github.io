<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>B·∫£ng LED Ma Tr·∫≠n ARGB V3 Ultimate - T√πy Bi·∫øn B√≥ng LED & Hi·ªáu ·ª®ng</title>
    <meta name="description" content="Tr√¨nh gi·∫£ l·∫≠p b·∫£ng LED ƒëi·ªán t·ª≠ V3. T√πy ch·ªânh ki·ªÉu d√°ng b√≥ng LED tr√≤n/vu√¥ng, hi·ªáu ·ª©ng g√µ ch·ªØ, vi·ªÅn sao r∆°i, 16 tri·ªáu m√†u ARGB. C√¥ng c·ª• t·∫°o bi·ªÉn qu·∫£ng c√°o s·ªë 1 Vi·ªát Nam.">
    
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      "name": "LED Matrix Simulator V3 Ultimate",
      "applicationCategory": "DesignTool",
      "featureList": "Round/Square LED Shapes, Typewriter Effect, Starfall Border, ARGB Colors, Fullscreen Mode",
      "operatingSystem": "Web Browser",
      "offers": { "@type": "Offer", "price": "0" }
    }
    </script>

    <style>
        :root { --bg: #050505; --panel: #1a1a1a; --accent: #ffae00; --text: #eee; }
        body { background: var(--bg); color: var(--text); font-family: 'Segoe UI', Roboto, sans-serif; margin: 0; display: flex; flex-direction: column; align-items: center; min-height: 100vh; }
        
        /* CSS gi·ªØ nguy√™n t·ª´ V2, ch·ªâ c·∫≠p nh·∫≠t m√†u accent */
        header { width: 100%; background: #000; padding: 15px; text-align: center; border-bottom: 2px solid #333; box-shadow: 0 0 20px rgba(255, 174, 0, 0.2); }
        h1 { margin: 0; color: var(--accent); text-transform: uppercase; font-size: 1.8rem; letter-spacing: 3px; text-shadow: 0 0 10px var(--accent); }
        
        #led-wrapper {
            margin: 20px auto; padding: 8px; background: #000; border-radius: 10px;
            box-shadow: 0 0 60px rgba(0,0,0,0.95); border: 3px solid #222; max-width: 98vw;
            overflow: hidden;
        }
        canvas { display: block; background: #000; cursor: crosshair; }

        .controls {
            background: var(--panel); width: 95%; max-width: 1200px; padding: 20px; border-radius: 12px;
            display: grid; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); gap: 15px;
            border: 1px solid #333; margin-bottom: 40px; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        .group { background: #222; padding: 12px; border-radius: 8px; border-left: 3px solid var(--accent); display: flex; flex-direction: column; gap: 8px; }
        .group-title { font-size: 0.9rem; color: var(--accent); font-weight: bold; margin-bottom: 5px; text-transform: uppercase; }
        label { font-size: 0.8rem; color: #bbb; font-weight: 600; }
        
        input, select { width: 100%; padding: 8px 10px; background: #333; border: 1px solid #444; color: #fff; border-radius: 4px; box-sizing: border-box; outline: none; transition: border 0.3s; font-family: inherit; }
        input:focus, select:focus { border-color: var(--accent); }
        input[type="range"] { padding: 0; cursor: pointer; height: 6px; accent-color: var(--accent); }
        input[type="color"] { padding: 2px; height: 38px; cursor: pointer; }
        
        .row-flex { display: flex; gap: 10px; align-items: center; }
        .btn-full { grid-column: 1 / -1; background: linear-gradient(135deg, var(--accent), #ff5500); color: #000; border: none; padding: 15px; font-weight: 900; text-transform: uppercase; cursor: pointer; font-size: 1.2rem; letter-spacing: 1px; border-radius: 6px; transition: all 0.3s; box-shadow: 0 5px 15px rgba(255, 174, 0, 0.3); }
        .btn-full:hover { transform: translateY(-2px); box-shadow: 0 10px 25px rgba(255, 174, 0, 0.5); }
        .btn-full:active { transform: scale(0.98); }

        body.fullscreen #led-wrapper { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; margin: 0; padding: 0; border: none; z-index: 9999; display: flex; align-items: center; justify-content: center; background: #000; }
        body.fullscreen canvas { width: 100% !important; height: 100% !important; object-fit: contain; }
        body.fullscreen header, body.fullscreen .controls { display: none; }
    </style>
</head>
<body>
    <header>
        <h1>LED Matrix V3 Ultimate Simulator</h1>
    </header>

    <div id="led-wrapper">
        <canvas id="ledCanvas"></canvas>
    </div>

    <div class="controls">
        <div class="group">
            <div class="group-title">1. N·ªôi Dung & M√†u S·∫Øc</div>
            <input type="text" id="textInput" value="H√Ä N·ªòI PH·ªê ƒê√äM NAY" placeholder="Nh·∫≠p n·ªôi dung...">
            <div class="row-flex">
                <input type="color" id="textColor" value="#ffae00" title="Ch·ªçn m√†u ch·ªØ">
                <select id="colorMode">
                    <option value="solid">M√†u ƒê∆°n S·∫Øc</option>
                    <option value="rainbow">üåà 7 S·∫Øc C·∫ßu V·ªìng</option>
                    <option value="gradient">üî• L·ª≠a (Gradient)</option>
                </select>
            </div>
        </div>

        <div class="group">
             <div class="group-title">2. Hi·ªáu ·ª®ng Ch·ªØ (Text FX)</div>
            <select id="moveType">
                <option value="left">‚¨ÖÔ∏è Ch·∫°y tr√°i (C·ªï ƒëi·ªÉn)</option>
                <option value="wave">üåä S√≥ng n∆∞·ªõc (Wave)</option>
                <option value="bounce">üèÄ N·∫£y (Bounce)</option>
                <option value="typing">‚å®Ô∏è G√µ m√°y (Typewriter) [NEW]</option>
                <option value="pulse">üíì Nh·ªãp tim (Pulse) [NEW]</option>
                <option value="jitter">üì∫ Nhi·ªÖu s√≥ng (Glitch) [NEW]</option>
                <option value="static">üõë ƒê·ª©ng y√™n</option>
            </select>
            <label>T·ªëc ƒë·ªô FX:</label>
            <input type="range" id="textSpeed" min="1" max="30" value="5">
        </div>

        <div class="group">
            <div class="group-title">3. C·∫•u H√¨nh B√≥ng LED</div>
            <div class="row-flex">
                <div style="flex:1">
                     <label>Ki·ªÉu d√°ng:</label>
                    <select id="ledShape">
                        <option value="circle">‚ö™ B√≥ng Tr√≤n (Round)</option>
                        <option value="square">‚¨ú B√≥ng Vu√¥ng (Square)</option>
                    </select>
                </div>
                <div style="flex:1">
                     <label>K√≠ch th∆∞·ªõc:</label>
                     <input type="range" id="pixelScale" min="2" max="8" value="4" title="K√≠ch th∆∞·ªõc ƒëi·ªÉm ·∫£nh">
                </div>
            </div>
             <label>C·ª° ch·ªØ (Zoom):</label>
             <input type="range" id="textSize" min="20" max="120" value="55">
        </div>

         <div class="group">
            <div class="group-title">4. H·ªça Ti·∫øt Vi·ªÅn (Pattern)</div>
            <select id="borderPattern">
                <option value="solid">K·∫ª li·ªÅn (Solid)</option>
                <option value="marquee">üí° R·∫°p h√°t (Marquee) [NEW]</option>
                <option value="dotted">Ch·∫•m bi (Dotted)</option>
                <option value="barber">üíà S·ªçc ch√©o (Barber)</option>
                <option value="corner">‚≠ê 4 G√≥c</option>
            </select>
            <label>M√†u vi·ªÅn n·ªÅn:</label>
            <input type="color" id="borderColor" value="#333333">
        </div>

        <div class="group">
            <div class="group-title">5. Chuy·ªÉn ƒê·ªông Vi·ªÅn (Anim)</div>
            <select id="borderAnim">
                <option value="snake">üêç R·∫Øn sƒÉn m·ªìi (Snake)</option>
                <option value="dual">üêçüêç Ch·∫°y k√©p (Dual Chase) [NEW]</option>
                <option value="scanner">üö® Qu√©t (Scanner)</option>
                <option value="starfall">‚ú® Sao r∆°i (Starfall) [NEW]</option>
                <option value="flow">üåà C·∫ßu v·ªìng tr√¥i (RGB Flow)</option>
                <option value="blink">‚ö†Ô∏è Nh·∫•p nh√°y (Blink)</option>
                <option value="static">ƒê·ª©ng y√™n</option>
                <option value="none">T·∫Øt vi·ªÅn</option>
            </select>
            <div class="row-flex">
                <label style="flex:1">T·ªëc ƒë·ªô:</label>
                <input type="range" id="borderSpeed" min="1" max="50" value="20" style="flex:2">
            </div>
        </div>

        <button class="btn-full" id="fsBtn">üñ•Ô∏è B·∫≠t Ch·∫ø ƒê·ªô Full M√†n H√¨nh (F11)</button>
    </div>

    <script>
        /**
         * LED MATRIX CORE V3 ULTIMATE
         * Advanced Canvas rendering with Shape Engine and Complex FX
         */
        const canvas = document.getElementById('ledCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimize
        
        // C·∫•u h√¨nh h·ªá th·ªëng
        let config = {
            rows: 64, cols: 192,
            pixelSize: 4, gap: 1,
            // State variables
            frame: 0,
            textX: 0, textY: 0, vx: 2,
            borderOffset: 0,
            hue: 0,
            // Typing FX state
            typewriterText: "",
            typewriterIndex: 0,
            lastTypeTime: 0
        };

        // UI Elements Reference
        const ui = {
            text: document.getElementById('textInput'), textColor: document.getElementById('textColor'), colorMode: document.getElementById('colorMode'),
            moveType: document.getElementById('moveType'), textSpeed: document.getElementById('textSpeed'),
            ledShape: document.getElementById('ledShape'), pixelScale: document.getElementById('pixelScale'), textSize: document.getElementById('textSize'),
            borderPattern: document.getElementById('borderPattern'), borderColor: document.getElementById('borderColor'),
            borderAnim: document.getElementById('borderAnim'), borderSpeed: document.getElementById('borderSpeed')
        };

        // H√†m kh·ªüi t·∫°o/resize canvas
        function initCanvas() {
            config.pixelSize = parseInt(ui.pixelScale.value);
            const w = config.cols * (config.pixelSize + config.gap) + config.gap;
            const h = config.rows * (config.pixelSize + config.gap) + config.gap;
            if(canvas.width !== w) canvas.width = w;
            if(canvas.height !== h) canvas.height = h;
            canvas.style.width = '100%'; canvas.style.height = '100%'; // CSS Aspect Ratio
        }

        // --- SHAPE ENGINE (L√µi v·∫Ω h√¨nh d√°ng LED) ---
        // V·∫Ω m·ªôt ƒëi·ªÉm LED t·∫°i t·ªça ƒë·ªô c·ªôt/h√†ng
        function drawLEDPixel(col, row, color) {
            const x = config.gap + col * (config.pixelSize + config.gap);
            const y = config.gap + row * (config.pixelSize + config.gap);
            const shape = ui.ledShape.value;

            ctx.fillStyle = color;
            if (shape === 'square') {
                ctx.fillRect(x, y, config.pixelSize, config.pixelSize);
            } else {
                // V·∫Ω h√¨nh tr√≤n
                const radius = config.pixelSize / 2;
                ctx.beginPath();
                ctx.arc(x + radius, y + radius, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- BORDER ENGINE V3 (H·ªá th·ªëng vi·ªÅn ph·ª©c t·∫°p) ---
        function renderBorder() {
            const anim = ui.borderAnim.value;
            if (anim === 'none') return;

            const pattern = ui.borderPattern.value;
            const speed = parseInt(ui.borderSpeed.value);
            const baseColor = ui.borderColor.value;
            config.borderOffset += speed * 0.05;
            const perimeter = 2 * (config.cols + config.rows - 2);
            const pOffset = Math.floor(config.borderOffset);

            // H√†m t√≠nh m√†u cho 1 ƒëi·ªÉm vi·ªÅn
            const getPixelColor = (index, x, y) => {
                // 1. Pattern Logic
                let visible = true;
                if (pattern === 'dotted') visible = (index % 2 === 0);
                else if (pattern === 'marquee') visible = ((index + pOffset) % 4 === 0); // R·∫°p h√°t
                else if (pattern === 'barber') visible = ((x + y + pOffset) % 12 < 6);
                else if (pattern === 'corner') visible = (x < 8 || x > config.cols - 9) && (y < 8 || y > config.rows - 9);
                
                if (!visible && pattern !== 'solid') return null; // N·∫øu pattern ·∫©n, th√¨ t·∫Øt

                // 2. Animation Logic
                if (anim === 'static') return baseColor;
                if (anim === 'blink') return (config.frame % 30 < 15) ? baseColor : null;
                
                if (anim === 'snake') {
                    const pos = (index - pOffset) % perimeter;
                    const normPos = pos < 0 ? pos + perimeter : pos;
                    return (normPos < config.cols/1.5) ? 'red' : baseColor; // R·∫Øn ƒë·ªè tr√™n n·ªÅn base
                }
                
                if (anim === 'dual') {
                    // 2 con r·∫Øn ch·∫°y ng∆∞·ª£c chi·ªÅu
                    const pos1 = (index + pOffset) % perimeter;
                    const pos2 = (index - pOffset) % perimeter;
                    const tail = config.cols/3;
                    if(pos1 < tail) return '#00ff00'; // R·∫Øn xanh
                    if(pos2 > 0 && pos2 < tail) return '#0000ff'; // R·∫Øn xanh d∆∞∆°ng
                    return baseColor;
                }

                 if (anim === 'starfall') {
                     // Hi·ªáu ·ª©ng sao r∆°i ng·∫´u nhi√™n (D·ª±a tr√™n noise gi·∫£ l·∫≠p)
                     // S·ª≠ d·ª•ng h√†m sin/cos k·∫øt h·ª£p index v√† frame ƒë·ªÉ t·∫°o ƒë·ªô ng·∫´u nhi√™n gi·∫£
                     const noise = Math.sin(index * 13.1 + config.frame * speed * 0.1) * Math.cos(index * 7.3);
                     return (noise > 0.8) ? '#ffffff' : baseColor;
                 }

                if (anim === 'scanner') {
                    const scanPos = (Math.sin(config.frame * speed * 0.01) + 1) / 2 * perimeter;
                    if (Math.abs(index - scanPos) < config.cols/10) return '#ff0000';
                    return baseColor;
                }
                
                if (anim === 'flow') {
                    return `hsl(${(index * 3 + config.frame * speed) % 360}, 100%, 50%)`;
                }

                return baseColor;
            };

            // V·∫Ω vi·ªÅn d√πng Shape Engine
            for (let x = 0; x < config.cols; x++) {
                let c = getPixelColor(x, x, 0); if(c) drawLEDPixel(x, 0, c); // Top
                c = getPixelColor(perimeter - config.rows + 2 - x, x, config.rows-1); if(c) drawLEDPixel(x, config.rows - 1, c); // Bot
            }
            for (let y = 1; y < config.rows - 1; y++) {
                let c = getPixelColor(config.cols + y - 1, config.cols-1, y); if(c) drawLEDPixel(config.cols - 1, y, c); // Right
                c = getPixelColor(perimeter - y, 0, y); if(c) drawLEDPixel(0, y, c); // Left
            }
        }

        // --- TEXT ENGINE V3 (H·ªá th·ªëng ch·ªØ FX m·ªõi) ---
        function renderText() {
            let text = ui.text.value;
            // X·ª≠ l√Ω Typewriter
            if (ui.moveType.value === 'typing') {
                const now = Date.now();
                const typeSpeed = 200 - parseInt(ui.textSpeed.value) * 5; // T·ªëc ƒë·ªô g√µ
                if (now - config.lastTypeTime > typeSpeed) {
                    config.typewriterIndex++;
                    if (config.typewriterIndex > text.length + 5) config.typewriterIndex = 0; // +5 ƒë·ªÉ delay khi g√µ xong
                    config.lastTypeTime = now;
                }
                text = text.substring(0, config.typewriterIndex) + "_"; // Th√™m con tr·ªè
            }

            let fontSize = parseInt(ui.textSize.value);
            const speed = parseInt(ui.textSpeed.value);
            const mode = ui.moveType.value;

            // X·ª≠ l√Ω hi·ªáu ·ª©ng Pulse v√† Jitter ·∫£nh h∆∞·ªüng ƒë·∫øn font/v·ªã tr√≠
            let drawX = config.textX, drawY = config.textY;
            if (mode === 'pulse') {
                fontSize += Math.sin(config.frame * speed * 0.05) * 10;
            } else if (mode === 'jitter') {
                 if(Math.random() > 0.8) {
                     drawX += (Math.random() - 0.5) * 10;
                     drawY += (Math.random() - 0.5) * 5;
                 }
            }

            ctx.font = `900 ${fontSize}px monospace`;
            ctx.textBaseline = 'middle';
            const textWidth = ctx.measureText(text).width;

            // Logic di chuy·ªÉn
            if(mode === 'left' || mode === 'wave' || mode === 'jitter') {
                config.textX -= speed; if (config.textX < -textWidth) config.textX = canvas.width;
                config.textY = canvas.height / 2;
            } else if (mode === 'bounce') {
                 config.textX += config.vx * (speed/5);
                 if(config.textX < 0 || config.textX + textWidth > canvas.width) config.vx *= -1;
                 config.textY = canvas.height / 2;
            } else {
                // Static, typing, pulse
                config.textX = (canvas.width - textWidth) / 2;
                config.textY = canvas.height / 2;
            }

            if (mode === 'wave') drawY += Math.sin(config.frame * 0.1) * (canvas.height / 5);
            if (mode === 'typing' || mode === 'pulse') { drawX = config.textX; drawY = config.textY; }


            // M√†u s·∫Øc
            let fillStyle = ui.textColor.value;
            if (ui.colorMode.value === 'rainbow') {
                config.hue = (config.hue + speed) % 360; fillStyle = `hsl(${config.hue}, 100%, 50%)`;
            } else if (ui.colorMode.value === 'gradient') {
                const grad = ctx.createLinearGradient(drawX, 0, drawX + textWidth, 0);
                grad.addColorStop(0, "#ff0000"); grad.addColorStop(0.5, "#ffff00"); grad.addColorStop(1, "#ff00ff");
                fillStyle = grad;
            }

            // V·∫Ω ch·ªØ (Solid)
            ctx.fillStyle = fillStyle;
            // T·∫°o hi·ªáu ·ª©ng ph√°t s√°ng nh·∫π cho ch·ªØ
            ctx.shadowBlur = config.pixelSize * 2; ctx.shadowColor = fillStyle;
            ctx.fillText(text, drawX, drawY);
            ctx.shadowBlur = 0;
        }

        // K·ªπ thu·∫≠t c·∫Øt l∆∞·ªõi ƒë·ªÉ t·∫°o ƒëi·ªÉm ·∫£nh
        function applyGridMask() {
            ctx.save();
            ctx.globalCompositeOperation = 'destination-out'; // Ch·∫ø ƒë·ªô "ƒë·ª•c l·ªó"
            ctx.fillStyle = '#000';
            
            // V·∫Ω c√°c ƒë∆∞·ªùng k·∫ª ƒëen ƒë·ªÉ c·∫Øt ch·ªØ th√†nh pixel
            // L∆∞u √Ω: K·ªπ thu·∫≠t n√†y ch·ªâ t·∫°o ra c√°c v·∫øt c·∫Øt vu√¥ng. 
            // ƒê·ªÉ text c√≥ d·∫°ng tr√≤n th·∫≠t s·ª± c·∫ßn thu·∫≠t to√°n ph·ª©c t·∫°p h∆°n nhi·ªÅu l√†m gi·∫£m hi·ªáu nƒÉng.
            // ·ªû ƒë√¢y ta ch·∫•p nh·∫≠n text b·ªã c·∫Øt vu√¥ng, nh∆∞ng n·ªÅn v√† vi·ªÅn s·∫Ω tr√≤n (n·∫øu ch·ªçn).
            for (let x = 0; x < canvas.width; x += (config.pixelSize + config.gap)) {
                ctx.fillRect(x + config.pixelSize, 0, config.gap, canvas.height);
            }
            for (let y = 0; y < canvas.height; y += (config.pixelSize + config.gap)) {
                ctx.fillRect(0, y + config.pixelSize, canvas.width, config.gap);
            }
            ctx.restore();
        }

        // --- MAIN LOOP ---
        function animate() {
            initCanvas(); // Check resize m·ªói frame

            // 1. N·ªÅn t·ªëi
            ctx.fillStyle = '#080808'; ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 2. V·∫Ω n·ªÅn LED t·∫Øt m·ªù m·ªù (S·ª≠ d·ª•ng Shape Engine ƒë·ªÉ v·∫Ω ƒë√∫ng ki·ªÉu d√°ng)
            for (let y = 1; y < config.rows - 1; y++) {
                for (let x = 1; x < config.cols - 1; x++) {
                    drawLEDPixel(x, y, '#141414');
                }
            }

            // 3. V·∫Ω v√† c·∫Øt ch·ªØ
            renderText();
            applyGridMask();

            // 4. V·∫Ω vi·ªÅn (ƒë√® l√™n tr√™n c√πng)
            renderBorder();

            config.frame++;
            requestAnimationFrame(animate);
        }

        // Events
        ui.pixelScale.addEventListener('input', initCanvas);
        document.getElementById('fsBtn').addEventListener('click', () => document.body.classList.toggle('fullscreen'));
        canvas.addEventListener('dblclick', () => document.body.classList.toggle('fullscreen'));

        animate(); // Start
    </script>
</body>
</html>
