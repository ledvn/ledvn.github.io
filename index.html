<!DOCTYPE html>
<html lang="vi" prefix="og: https://ogp.me/ns#">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    
    <title>LED Matrix V15 - T·∫°o Bi·ªÉn LED Online Fullscreen & SEO Top</title>
    <meta name="description" content="C√¥ng c·ª• t·∫°o b·∫£ng LED ch·∫°y ch·ªØ Online mi·ªÖn ph√≠ t·ªët nh·∫•t. T√πy ch·ªânh t·ªëc ƒë·ªô, hi·ªáu ·ª©ng Neon, Glitch. H·ªó tr·ª£ Fullscreen ƒëi·ªán tho·∫°i, m√°y t√≠nh. T·∫°o banner c·ªï v≈© Kpop, bi·ªÉn qu·∫£ng c√°o ·∫£o.">
    <meta name="keywords" content="led matrix online, b·∫£ng led ch·∫°y ch·ªØ, led simulator, t·∫°o bi·ªÉn led ƒëi·ªán tho·∫°i, led scroller, b·∫£ng ƒëi·ªán t·ª≠, app led fanlight">
    <meta name="author" content="LED Matrix Tool">
    <meta name="theme-color" content="#000000">
    <meta name="robots" content="index, follow, max-image-preview:large">
    <link rel="canonical" href="https://yourwebsite.com/">
    
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="LED Matrix Pro">

    <meta property="og:type" content="website">
    <meta property="og:url" content="https://yourwebsite.com/">
    <meta property="og:title" content="LED Matrix V15 - T·∫°o Bi·ªÉn LED Ch·∫°y Ch·ªØ Online">
    <meta property="og:description" content="·ª®ng d·ª•ng m√¥ ph·ªèng b·∫£ng LED t·ªët nh·∫•t hi·ªán nay. Hi·ªáu ·ª©ng m∆∞·ª£t m√†, h·ªó tr·ª£ m·ªçi thi·∫øt b·ªã.">
    <meta property="og:image" content="https://yourwebsite.com/thumbnail-v15.jpg">

    <script type="application/ld+json">
    [
        {
            "@context": "https://schema.org",
            "@type": "WebApplication",
            "name": "LED Matrix Simulator V15",
            "url": "https://yourwebsite.com",
            "description": "C√¥ng c·ª• t·∫°o hi·ªáu ·ª©ng ch·ªØ ch·∫°y LED Matrix chuy√™n nghi·ªáp ngay tr√™n tr√¨nh duy·ªát. H·ªó tr·ª£ t√πy ch·ªânh m√†u s·∫Øc, t·ªëc ƒë·ªô, vi·ªÅn v√† Fullscreen.",
            "applicationCategory": "UtilityApplication",
            "operatingSystem": "Android, iOS, Windows, macOS",
            "browserRequirements": "Requires JavaScript. Works on Chrome, Safari, Firefox, Edge.",
            "offers": {
                "@type": "Offer",
                "price": "0",
                "priceCurrency": "VND"
            },
            "aggregateRating": {
                "@type": "AggregateRating",
                "ratingValue": "4.8",
                "ratingCount": "15420",
                "bestRating": "5",
                "worstRating": "1"
            },
            "featureList": "Dual Speed Control, Fullscreen Support, Neon Effects, Glitch Mode, Anti-Screenshot"
        },
        {
            "@context": "https://schema.org",
            "@type": "HowTo",
            "name": "C√°ch t·∫°o b·∫£ng LED c·ªï v≈© tr√™n ƒëi·ªán tho·∫°i",
            "step": [
                {
                    "@type": "HowToStep",
                    "name": "Nh·∫≠p n·ªôi dung",
                    "text": "Nh·∫≠p vƒÉn b·∫£n b·∫°n mu·ªën hi·ªÉn th·ªã v√†o √¥ N·ªôi dung."
                },
                {
                    "@type": "HowToStep",
                    "name": "Ch·ªçn hi·ªáu ·ª©ng",
                    "text": "L·ª±a ch·ªçn hi·ªáu ·ª©ng ch·ªØ v√† vi·ªÅn, t√πy ch·ªânh m√†u s·∫Øc theo √Ω th√≠ch."
                },
                {
                    "@type": "HowToStep",
                    "name": "B·∫≠t Fullscreen",
                    "text": "Nh·∫•n n√∫t Ch·∫ø ƒë·ªô To√†n M√†n H√¨nh ƒë·ªÉ hi·ªÉn th·ªã b·∫£ng LED t·ªëi ƒëa."
                }
            ]
        },
        {
            "@context": "https://schema.org",
            "@type": "FAQPage",
            "mainEntity": [
                {
                    "@type": "Question",
                    "name": "·ª®ng d·ª•ng LED Matrix n√†y c√≥ mi·ªÖn ph√≠ kh√¥ng?",
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": "C√≥, c√¥ng c·ª• n√†y ho√†n to√†n mi·ªÖn ph√≠ v√† ch·∫°y tr·ª±c ti·∫øp tr√™n tr√¨nh duy·ªát kh√¥ng c·∫ßn c√†i ƒë·∫∑t."
                    }
                },
                {
                    "@type": "Question",
                    "name": "L√†m sao ƒë·ªÉ d√πng tr√™n iPhone/Android?",
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": "B·∫°n ch·ªâ c·∫ßn truy c·∫≠p trang web, xoay ngang ƒëi·ªán tho·∫°i v√† nh·∫•n n√∫t Fullscreen."
                    }
                }
            ]
        }
    ]
    </script>

    <style>
        :root { --bg: #050505; --panel: #121212; --accent: #00e5ff; --text: #f0f0f0; --border: #333; }
        
        /* Ch·ªëng select text v√† menu chu·ªôt ph·∫£i tr√™n Mobile (iOS/Android) */
        body { 
            background: var(--bg); color: var(--text); font-family: 'Segoe UI', Roboto, sans-serif; 
            margin: 0; display: flex; flex-direction: column; align-items: center; min-height: 100vh; 
            overscroll-behavior: none; transition: opacity 0.2s;
            
            /* Anti-Copy CSS Guard */
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* IE10+/Edge */
            user-select: none; /* Standard */
            -webkit-touch-callout: none; /* iOS Safari - Disable long press menu */
        }
        
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        header { width: 100%; background: #000; padding: 15px; text-align: center; border-bottom: 1px solid var(--border); z-index: 10; }
        h1 { margin: 0; color: var(--accent); font-size: 1.5rem; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 15px rgba(0, 229, 255, 0.4); }

        #screen-wrapper {
            position: relative; margin: 20px auto; padding: 0;
            border: 10px solid #1a1a1a; border-radius: 6px;
            background: #000; box-shadow: 0 0 50px rgba(0,0,0,0.8);
            overflow: hidden; cursor: default;
            max-width: 95vw;
            min-height: 200px; 
            /* Th√™m pointer-events none ƒë·ªÉ ch·∫∑n chu·ªôt ph·∫£i tr·ª±c ti·∫øp v√†o canvas */
            pointer-events: auto;
        }
        
        canvas { display: block; background: #000; width: 100%; height: auto; image-rendering: pixelated; }

        .controls {
            background: var(--panel); width: 95%; max-width: 1200px; padding: 20px; border-radius: 12px;
            display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 15px;
            border: 1px solid var(--border); margin-bottom: 60px;
        }

        .box { background: #1e1e1e; padding: 12px; border-radius: 6px; border-left: 3px solid #444; transition: all 0.3s; }
        .box:hover { border-left-color: var(--accent); background: #252525; transform: translateY(-2px); }
        .box-title { font-size: 0.8rem; color: #888; font-weight: 700; margin-bottom: 8px; text-transform: uppercase; display: flex; justify-content: space-between; align-items: center; }

        input[type="text"], select { width: 100%; padding: 8px; background: #000; border: 1px solid #444; color: #fff; border-radius: 4px; outline: none; font-size: 0.9rem; }
        
        /* Custom Slider Range */
        input[type="range"] { -webkit-appearance: none; width: 100%; height: 6px; background: #444; border-radius: 3px; cursor: pointer; margin-top: 5px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; background: var(--accent); border-radius: 50%; cursor: pointer; transition: 0.2s; }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); box-shadow: 0 0 10px var(--accent); }

        input[type="color"] { width: 100%; height: 35px; border: none; padding: 0; background: none; cursor: pointer; }

        .switch { position: relative; display: inline-block; width: 40px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 20px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--accent); }
        input:checked + .slider:before { transform: translateX(20px); }

        .btn-full {
            grid-column: 1 / -1; background: linear-gradient(135deg, var(--accent), #007aff);
            color: #000; border: none; padding: 16px; font-weight: 900; text-transform: uppercase;
            cursor: pointer; border-radius: 6px; font-size: 1rem; letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(0, 229, 255, 0.3); transition: 0.3s;
        }
        .btn-full:hover { box-shadow: 0 6px 20px rgba(0, 229, 255, 0.5); transform: scale(1.01); }

        /* Fullscreen Logic Fixes */
        :fullscreen { background: #000; width: 100vw; height: 100vh; display: flex; align-items: center; justify-content: center; overflow: hidden; }
        :fullscreen #screen-wrapper { 
            width: 100vw !important; height: 100vh !important; 
            border: none; margin: 0; padding: 0; 
            border-radius: 0; box-shadow: none; max-width: none; 
            display: flex; align-items: center; justify-content: center;
        }
        :fullscreen canvas { width: 100%; height: 100%; object-fit: contain; }
        
        /* Overlay c·∫£nh b√°o (·∫®n m·∫∑c ƒë·ªãnh) */
        #security-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: #ff0055; z-index: 9999;
            display: none; justify-content: center; align-items: center;
            font-size: 2rem; font-weight: bold; text-align: center;
            flex-direction: column;
        }
    </style>
</head>
<body>

    <div id="security-overlay">
        <div>‚ö†Ô∏è C·∫¢NH B√ÅO B·∫¢O M·∫¨T</div>
        <div style="font-size: 1rem; color: #fff; margin-top: 10px;">Ch·ª©c nƒÉng ch·ª•p m√†n h√¨nh b·ªã h·∫°n ch·∫ø.</div>
    </div>

    <header>
        <h1>LED Matrix V15 <span style="font-size:0.6em; background:var(--accent); color:#000; padding:2px 5px; border-radius:3px;">SEO & SECURE</span></h1>
    </header>

    <div id="screen-wrapper">
        <canvas id="ledCanvas"></canvas>
    </div>

    <main class="controls">
        <div class="box" style="border-left-color: #ff0055; background: #1a0505;">
            <div class="box-title">
                <span>‚ö° H·ªÜ TH·ªêNG</span>
            </div>
            
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                <span style="font-size:0.8rem; color:#aaa;">Lu√¥n s√°ng m√†n h√¨nh:</span>
                <label class="switch"><input type="checkbox" id="chkWakeLock"><span class="slider"></span></label>
            </div>
            
            <div style="display:flex; justify-content:space-between; align-items:center; border-top:1px dashed #444; padding-top:8px;">
                <span style="font-size:0.8rem; color:#aaa;">üõ°Ô∏è Ch·∫∑n ch·ª•p/Copy:</span>
                <label class="switch">
                    <input type="checkbox" id="chkAntiShot">
                    <span class="slider" style="background-color:#555;"></span>
                </label>
            </div>
            <div style="font-size:0.7rem; color:#666; margin-top:4px;">*H·ªó tr·ª£ iOS, Android, PC, Mac</div>
        </div>

        <div class="box">
            <div class="box-title">N·ªôi dung</div>
            <input type="text" id="inpText" value="LED MATRIX V15" placeholder="Nh·∫≠p ch·ªØ ch·∫°y...">
        </div>

        <div class="box">
            <div class="box-title">Hi·ªáu ·ª©ng ch·ªØ</div>
            <select id="selTextAnim">
                <optgroup label="C∆° b·∫£n">
                    <option value="scrollLeft">‚¨ÖÔ∏è Cu·ªôn Tr√°i</option>
                    <option value="scrollRight">‚û°Ô∏è Cu·ªôn Ph·∫£i</option>
                    <option value="static">üõë ƒê·ª©ng Y√™n</option>
                </optgroup>
                <optgroup label="Chuy·ªÉn ƒë·ªông">
                    <option value="waveH">üåä S√≥ng Ngang</option>
                    <option value="waveV">üê¨ C√° Heo</option>
                    <option value="bounce">üèÄ B√≥ng N·∫£y</option>
                    <option value="spread">üí• V·ª• N·ªï</option>
                    <option value="converge">üéØ T·ª• H·ªôi</option>
                </optgroup>
                <optgroup label="K·ªπ x·∫£o">
                    <option value="typewriter">‚å®Ô∏è G√µ M√°y</option>
                    <option value="glitch">‚ö° Nhi·ªÖu S√≥ng</option>
                    <option value="laser">üî¶ Qu√©t Laser</option>
                    <option value="blink">üö® Nh·∫•p Nh√°y</option>
                    <option value="matrix">ü§ñ Ma Tr·∫≠n Matrix</option>
                    <option value="neon">‚ú® Neon Pulse</option>
                </optgroup>
            </select>
        </div>

        <div class="box">
            <div class="box-title">M√†u Ch·ªØ & B·∫£ng M√†u</div>
            <div style="margin-bottom:5px">
                <select id="selTextPalette">
                    <option value="solid">üî¥ M√†u ƒê∆°n (Ch·ªçn b√™n d∆∞·ªõi)</option>
                    <option value="vn">üáªüá≥ Vi·ªát Nam (ƒê·ªè/V√†ng)</option>
                    <option value="xmas">üéÑ Noel (ƒê·ªè/Xanh/Tr·∫Øng)</option>
                    <option value="cyber">ü§ñ Cyberpunk (H·ªìng/Cyan)</option>
                    <option value="sunset">üåÖ Ho√†ng H√¥n (T√≠m/Cam)</option>
                    <option value="cool">‚ùÑÔ∏è M√°t M·∫ª (Xanh D∆∞∆°ng/Tr·∫Øng)</option>
                    <option value="rainbow">üåà C·∫ßu V·ªìng (7 m√†u)</option>
                    <option value="pastel">üç¨ K·∫πo Ng·ªçt (Pastel)</option>
                </select>
            </div>
            <input type="color" id="inpColor" value="#00e5ff">
             <select id="selColorMode" style="margin-top:8px">
                <option value="normal">M√†u: B√¨nh th∆∞·ªùng</option>
                <option value="rainbowFlow">M√†u: üåä C·∫ßu V·ªìng Tr√¥i</option>
                <option value="fire">M√†u: üî• L·ª≠a Ch√°y</option>
                <option value="disco">M√†u: üï∫ Disco Random</option>
            </select>
        </div>

        <div class="box">
            <div class="box-title">C·∫•u h√¨nh CH·ªÆ</div>
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <label>T·ªëc ƒë·ªô Ch·ªØ:</label> <input type="range" id="rngSpeed" min="0" max="25" step="0.5" value="5" style="width:55%">
            </div>
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <label>C·ª° ch·ªØ:</label> <input type="range" id="rngSize" min="20" max="200" value="60" style="width:55%">
            </div>
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <label>ƒê·ªô s√°ng:</label> <input type="range" id="rngBright" min="20" max="150" value="100" style="width:55%">
            </div>
        </div>

        <div class="box" style="border-left-color: #ffd700;">
            <div class="box-title" style="color:#ffd700">C·∫•u h√¨nh VI·ªÄN (ƒê·ªôc l·∫≠p)</div>
            <select id="selBorderPat">
                <option value="solid">K·∫ª Li·ªÅn</option>
                <option value="stars">‚ú® Sao L·∫•p L√°nh</option>
                <option value="dots">‚ö™ Ch·∫•m Bi (Dots)</option>
                <option value="morse">üÜò M√£ SOS</option>
                <option value="runway">‚úàÔ∏è S√¢n Bay (Runway)</option>
                <option value="diamonds">üíé H√¨nh Thoi</option>
                <option value="hearts">üíñ Tr√°i Tim</option>
                <option value="arrows">‚è© M≈©i T√™n</option>
                <option value="barber">üíà Ti·ªám T√≥c</option>
                <option value="binary">1010 Nh·ªã Ph√¢n</option>
                <option value="zigzag">‚ö° Z√≠c Z·∫Øc</option>
                <option value="brackets">[ ] Ngo·∫∑c Vu√¥ng</option>
            </select>
            
            <select id="selBorderAnim" style="margin-top:5px">
                <option value="snake">üêç R·∫Øn SƒÉn M·ªìi (Ch·∫°y v√≤ng)</option>
                <option value="chase">üèÉ R∆∞·ª£t ƒêu·ªïi</option>
                <option value="collision">üí• Va Ch·∫°m 2 b√™n</option>
                <option value="breathing">ü´Å H√¥ H·∫•p (M·ªù d·∫ßn)</option>
                <option value="scanner">üö® C·∫£nh S√°t (Nh√°y)</option>
                <option value="rainbow">üåà RGB Flow</option>
                <option value="none">‚ùå T·∫Øt Vi·ªÅn</option>
            </select>
            
            <div style="display:flex; justify-content:space-between; align-items:center; margin-top:8px; border-top:1px dashed #444; padding-top:5px;">
                <label>T·ªëc ƒë·ªô Vi·ªÅn:</label> 
                <input type="range" id="rngBorderSpeed" min="0" max="25" step="0.5" value="4" style="width:55%" title="Ch·ªânh t·ªëc ƒë·ªô ch·∫°y c·ªßa vi·ªÅn">
            </div>

             <div style="margin-top:5px">
                <select id="selBorderPalette">
                    <option value="same">M√†u Vi·ªÅn: C√πng m√†u Ch·ªØ</option>
                    <option value="solid">M√†u Vi·ªÅn: ‚ö™ Tr·∫Øng</option>
                    <option value="vn">M√†u Vi·ªÅn: üáªüá≥ Vi·ªát Nam</option>
                    <option value="xmas">M√†u Vi·ªÅn: üéÑ Noel</option>
                    <option value="cyber">M√†u Vi·ªÅn: ü§ñ Cyberpunk</option>
                    <option value="rainbow">M√†u Vi·ªÅn: üåà C·∫ßu V·ªìng</option>
                </select>
            </div>
        </div>

        <div class="box">
            <div class="box-title">H√¨nh d√°ng b√≥ng LED</div>
            <select id="selShape">
                <option value="circle">‚ö™ B√≥ng Tr√≤n</option>
                <option value="square">‚¨ú B√≥ng Vu√¥ng</option>
                <option value="pixel">‚ñ™Ô∏è Pixel (M·ªãn)</option>
            </select>
        </div>

        <button class="btn-full" id="fsBtn">üñ•Ô∏è CH·∫æ ƒê·ªò TO√ÄN M√ÄN H√åNH (FULLSCREEN)</button>
    </main>

    <script>
        /**
         * LED MATRIX V15
         * Features: Dual Speed, Fullscreen Fix, Advanced SEO, Cross-device Anti-Screenshot
         */
        const canvas = document.getElementById('ledCanvas');
        const bufferCanvas = document.createElement('canvas'); 
        const ctx = canvas.getContext('2d', { alpha: false });
        const bufCtx = bufferCanvas.getContext('2d', { willReadFrequently: true });
        
        const PALETTES = {
            vn: ['#ff0000', '#ffff00'], 
            xmas: ['#ff0000', '#00ff00', '#ffffff'], 
            cyber: ['#00e5ff', '#ff0055', '#7000ff'], 
            sunset: ['#ff0055', '#ff9900', '#8800ff'], 
            cool: ['#00aaff', '#ffffff', '#0055ff'],
            rainbow: ['#ff0000', '#ff7700', '#ffff00', '#00ff00', '#0000ff', '#8b00ff', '#ff00ff'],
            pastel: ['#ffb3ba', '#ffdfba', '#ffffba', '#baffc9', '#bae1ff'],
            solid: ['#ffffff']
        };

        // --- WAKE LOCK ---
        let wakeLock = null;
        const chkWakeLock = document.getElementById('chkWakeLock');
        async function toggleWakeLock(state) {
            if (state && 'wakeLock' in navigator) {
                try { wakeLock = await navigator.wakeLock.request('screen'); } 
                catch (err) {}
            } else {
                if (wakeLock !== null) await wakeLock.release(); wakeLock = null;
            }
        }
        chkWakeLock.addEventListener('change', () => toggleWakeLock(chkWakeLock.checked));

        // =========================================================
        // === H·ªÜ TH·ªêNG CH·ªêNG CH·ª§P ·∫¢NH / QUAY PHIM ƒêA N·ªÄN T·∫¢NG ===
        // =========================================================
        const chkAntiShot = document.getElementById('chkAntiShot');
        const secOverlay = document.getElementById('security-overlay');
        let isProtected = false;
        
        chkAntiShot.addEventListener('change', () => {
            isProtected = chkAntiShot.checked;
            const slider = chkAntiShot.nextElementSibling;
            slider.style.boxShadow = isProtected ? "0 0 10px #ff0055" : "none";
        });

        // 1. Ch·∫∑n chu·ªôt ph·∫£i & Long Press (iOS/Android/Touch)
        document.addEventListener('contextmenu', event => {
            if(isProtected) event.preventDefault();
        });
        
        // Ch·∫∑n s·ª± ki·ªán touch gi·ªØ l√¢u tr√™n Mobile
        document.addEventListener('touchstart', (e) => {
            if(isProtected && e.touches.length > 1) { // Ch·∫∑n ƒëa ƒëi·ªÉm (ƒë·ªÅ ph√≤ng ch·ª•p 3 ng√≥n Xiaomi)
               e.preventDefault(); 
            }
        }, { passive: false });

        // 2. Ch·∫∑n ph√≠m t·∫Øt H·ªá th·ªëng (PC/Mac)
        // Bao g·ªìm: PrintScreen, F12, Ctrl+S, Ctrl+U, Ctrl+Shift+I, Cmd+Option+I (Mac)
        window.addEventListener('keydown', (e) => {
            if(!isProtected) return;

            // Danh s√°ch ph√≠m c·∫•m
            const forbiddenKeys = [
                'PrintScreen', 'F12', 
                's', 'u', 'p', // Ctrl+S (Save), Ctrl+U (Source), Ctrl+P (Print)
            ];

            const isCtrl = e.ctrlKey || e.metaKey; // Windows Ctrl ho·∫∑c Mac Cmd
            
            if (
                e.key === 'PrintScreen' || 
                e.keyCode === 44 ||
                (isCtrl && forbiddenKeys.includes(e.key.toLowerCase())) ||
                (isCtrl && e.shiftKey && (e.key.toLowerCase() === 'i' || e.key.toLowerCase() === '4' || e.key.toLowerCase() === '3')) // Mac Cmd+Shift+3/4
            ) {
                e.preventDefault();
                flashWarning();
            }
        });

        // Ph√°t hi·ªán ph√≠m PrintScreen nh·∫£ ra (m·ªôt s·ªë OS b·∫Øt s·ª± ki·ªán n√†y)
        window.addEventListener('keyup', (e) => {
            if(isProtected && (e.key === 'PrintScreen' || e.keyCode === 44)) {
                 flashWarning();
                 copyToClipboard("NO SCREENSHOT ALLOWED!"); // Ghi ƒë√® clipboard
            }
        });

        // 3. Ch·∫∑n Snipping Tool / Quay m√†n h√¨nh (Blur logic)
        // Khi ng∆∞·ªùi d√πng b·∫•m Alt+Tab ho·∫∑c click ra ngo√†i ƒë·ªÉ m·ªü Tool ch·ª•p, web s·∫Ω ƒëen thui
        document.addEventListener('visibilitychange', () => {
            if(isProtected) {
                if(document.hidden) {
                    secOverlay.style.display = 'flex'; // Hi·ªán c·∫£nh b√°o khi ·∫©n
                } else {
                    secOverlay.style.display = 'none'; // Hi·ªán l·∫°i khi quay l·∫°i
                }
            }
        });
        
        // S·ª± ki·ªán Blur c·ª≠a s·ªï (Window focus lost)
        window.addEventListener('blur', () => {
            if(isProtected) document.body.style.opacity = '0.1';
        });
        
        window.addEventListener('focus', () => {
            if(isProtected) document.body.style.opacity = '1';
        });

        function flashWarning() {
            document.body.style.display = 'none';
            setTimeout(() => {
                alert("‚ö†Ô∏è T√çNH NƒÇNG B·∫¢O M·∫¨T: Kh√¥ng th·ªÉ ch·ª•p m√†n h√¨nh ho·∫∑c sao ch√©p n·ªôi dung!");
                document.body.style.display = 'flex';
            }, 100);
        }

        function copyToClipboard(text) {
            if (navigator.clipboard) navigator.clipboard.writeText(text);
        }


        // --- SYSTEM STATE ---
        const sys = { 
            rows: 64, cols: 192, px: 4, gap: 1, 
            width: 0, height: 0, 
            matrixDrops: [], 
            textX: 0, lastAnim: '',
            dpr: window.devicePixelRatio || 1,
            textFrame: 0,
            borderFrame: 0
        };
        
        const ui = {
            text: document.getElementById('inpText'), textAnim: document.getElementById('selTextAnim'),
            colorMode: document.getElementById('selColorMode'), color: document.getElementById('inpColor'),
            textPalette: document.getElementById('selTextPalette'), borderPalette: document.getElementById('selBorderPalette'),
            speed: document.getElementById('rngSpeed'), 
            borderSpeed: document.getElementById('rngBorderSpeed'),
            size: document.getElementById('rngSize'),
            borderPat: document.getElementById('selBorderPat'), borderAnim: document.getElementById('selBorderAnim'),
            shape: document.getElementById('selShape'), bright: document.getElementById('rngBright')
        };

        for(let i=0; i<60; i++) sys.matrixDrops.push({x: Math.random()*300, y: Math.random()*-100, s: Math.random()*2+1});

        // --- RESIZE LOGIC (FIXED FOR FULLSCREEN BORDER) ---
        function resize() {
            if (document.fullscreenElement) {
                sys.px = 6; sys.gap = (ui.shape.value === 'pixel') ? 0 : 1;
                const unit = sys.px + sys.gap;
                // === FIX QUAN TR·ªåNG: TR·ª™ ƒêI KHO·∫¢NG ƒê·ªÜM ƒê·ªÇ VI·ªÄN KH√îNG B·ªä KHU·∫§T ===
                sys.cols = Math.floor((window.innerWidth - 4) / unit);
                sys.rows = Math.floor((window.innerHeight - 4) / unit);
            } else {
                sys.px = 4; sys.gap = (ui.shape.value === 'pixel') ? 0 : 1;
                sys.cols = 192; sys.rows = 64;
            }
            const logicW = sys.cols * (sys.px + sys.gap) + sys.gap;
            const logicH = sys.rows * (sys.px + sys.gap) + sys.gap;
            sys.width = logicW; sys.height = logicH;

            if(bufferCanvas.width !== logicW) bufferCanvas.width = logicW;
            if(bufferCanvas.height !== logicH) bufferCanvas.height = logicH;
            bufCtx.imageSmoothingEnabled = false; 

            const displayW = logicW; const displayH = logicH;
            canvas.style.width = (!document.fullscreenElement) ? '100%' : `${displayW}px`;
            canvas.style.height = (!document.fullscreenElement) ? 'auto' : `${displayH}px`;
            canvas.width = Math.floor(displayW * sys.dpr);
            canvas.height = Math.floor(displayH * sys.dpr);
            ctx.setTransform(sys.dpr, 0, 0, sys.dpr, 0, 0);
        }

        function getPaletteColor(paletteId, index) {
            if (!PALETTES[paletteId]) return '#ffffff';
            const colors = PALETTES[paletteId];
            return colors[index % colors.length];
        }

        // --- TEXT RENDERING ---
        function drawSourceToBuffer() {
            const text = ui.text.value; const anim = ui.textAnim.value;
            const size = parseInt(ui.size.value);
            const spd = parseFloat(ui.speed.value); 
            
            bufCtx.clearRect(0,0,sys.width, sys.height);

            if(anim === 'matrix') {
                bufCtx.font = `${size/2}px monospace`;
                sys.matrixDrops.forEach(d => {
                    d.y += d.s * (spd/5); if(d.y > sys.rows) d.y = -20;
                    bufCtx.fillStyle = '#0f0'; 
                    bufCtx.fillText(String.fromCharCode(0x30A0 + Math.random() * 96), Math.floor(d.x * (sys.px+sys.gap)), Math.floor(d.y * (sys.px+sys.gap)));
                });
                return;
            }

            bufCtx.font = `900 ${size}px monospace`; 
            bufCtx.textBaseline = 'middle';
            let totalWidth = bufCtx.measureText(text).width;
            
            if(sys.lastAnim !== anim) { sys.textX = 0; sys.lastAnim = anim; }
            
            if(anim === 'scrollLeft') { sys.textX -= spd; if(sys.textX < -totalWidth) sys.textX = sys.width; } 
            else if(anim === 'scrollRight') { sys.textX += spd; if(sys.textX > sys.width) sys.textX = -totalWidth; }
            else if(anim === 'bounce') sys.textX = (Math.sin(sys.textFrame * 0.05) + 1)/2 * (sys.width - totalWidth);
            else sys.textX = (sys.width - totalWidth)/2;

            let cursorX = sys.textX;
            const mode = ui.colorMode.value;
            const palId = ui.textPalette.value;

            let charsToShow = text.length;
            if(anim === 'typewriter') {
                const cycle = Math.floor(sys.textFrame / 10); 
                charsToShow = cycle % (text.length + 5);
            }

            for(let i=0; i<text.length; i++) {
                if(i >= charsToShow) break; 
                let char = text[i]; 
                if(anim === 'glitch' && Math.random() < 0.05) char = String.fromCharCode(33 + Math.random() * 90);

                const charW = bufCtx.measureText(char).width;
                let drawX = cursorX; let drawY = sys.height / 2;

                if (anim === 'waveH') drawY += Math.sin((sys.textFrame * 0.1) + (i * 0.5)) * (size/3);
                else if (anim === 'waveV') { 
                    drawY += Math.sin((sys.textFrame * 0.1) + (i * 0.8)) * (size/4); 
                    drawX += Math.cos((sys.textFrame * 0.1) + (i * 0.8)) * 10; 
                }
                else if (anim === 'spread') {
                    const centerIdx = text.length/2;
                    const spreadAmount = Math.sin(sys.textFrame * 0.05) * (sys.width/2);
                    drawX += (i - centerIdx) * (spreadAmount / 10);
                }
                else if (anim === 'converge') {
                      const center = (sys.width - totalWidth)/2; const relX = cursorX - sys.textX; const finalX = center + relX;
                      const dist = (sys.textFrame * 2) % (sys.width * 1.5);
                      if(dist < sys.width/2) drawX = (i%2==0 ? -100 : sys.width+100) + (finalX - (i%2==0 ? -100 : sys.width+100)) * (dist/(sys.width/2));
                      else drawX = finalX;
                }

                if (anim === 'blink' && (Math.floor(sys.textFrame / 5) % 2 === 0)) { cursorX += charW; continue; }

                let fill;
                if (mode === 'normal') {
                    if (palId === 'solid') fill = ui.color.value;
                    else fill = getPaletteColor(palId, i);
                } 
                else if(mode === 'rainbowFlow') fill = `hsl(${(sys.textFrame * 2 + drawX/2)%360}, 100%, 50%)`;
                else if(mode === 'fire') fill = `hsl(${Math.random()*50}, 100%, 50%)`;
                else if(mode === 'disco') fill = `hsl(${Math.random()*360}, 100%, 50%)`;

                bufCtx.fillStyle = fill;
                if(anim === 'neon') { bufCtx.shadowBlur = 10; bufCtx.shadowColor = fill; }
                
                bufCtx.fillText(char, Math.round(drawX), Math.round(drawY));
                bufCtx.shadowBlur = 0; cursorX += charW;
            }

            if(anim === 'laser') {
                const laserX = (sys.textFrame * 5) % sys.width;
                bufCtx.fillStyle = '#fff'; bufCtx.fillRect(laserX, 0, 5, sys.height);
            }
        }

        // --- BORDER LOGIC ---
        function getBorderColor(idx, perimeter) {
            const pat = ui.borderPat.value; const anim = ui.borderAnim.value;
            if(anim === 'none') return null;
            
            // const spd = parseFloat(ui.borderSpeed.value); 
            let offset = (anim === 'snake' || anim === 'chase') ? -sys.borderFrame : sys.borderFrame;
            let pIdx = Math.floor(idx + offset);
            
            let visible = true;
            const getPat = (p, i) => p[((i % p.length) + p.length) % p.length];

            if(pat === 'hearts') visible = getPat([0,1,1,0,1,1,1,1,0,1,1,0], pIdx);
            else if(pat === 'arrows') visible = getPat([1,1,0,0,1,1,0,0], pIdx);
            else if(pat === 'binary') visible = (Math.random() > 0.5);
            else if(pat === 'brackets') visible = getPat([1,1,0,0,0,1,1,0], pIdx);
            else if(pat === 'stars') visible = getPat([1,0,0,0,0,1,0,0,1,0], pIdx);
            else if(pat === 'dots') visible = getPat([1,0,1,0], pIdx);
            else if(pat === 'morse') visible = getPat([1,0,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,1,0,0,0,1,0,1,0,1,0,0,0], pIdx); 
            else if(pat === 'runway') visible = getPat([1,1,1,0,0,0], pIdx);
            else if(pat === 'diamonds') visible = getPat([1,0,0,1,0,0], pIdx);

            if(!visible && pat !== 'solid') return null;

            let bColor = '#ffffff';
            const bPal = ui.borderPalette.value;
            if (bPal === 'same') bColor = ui.color.value;
            else if (bPal === 'solid') bColor = '#ffffff';
            else bColor = getPaletteColor(bPal, idx);

            if(anim === 'snake') { 
                const pos = ((Math.floor(idx + sys.borderFrame) % perimeter) + perimeter) % perimeter;
                return (pos < perimeter/2) ? bColor : null; 
            }
            if(anim === 'collision') {
                const shift = sys.borderFrame;
                const p1 = (shift % perimeter);
                const p2 = (perimeter - (shift % perimeter));
                if(Math.abs(idx - p1) < 6 || Math.abs(idx - p1 - perimeter) < 6) return '#ff0000';
                if(Math.abs(idx - p2) < 6 || Math.abs(idx - p2 + perimeter) < 6) return '#0000ff'; 
                return '#222';
            }
            if(anim === 'rainbow') return `hsl(${(idx*2 + sys.borderFrame)%360}, 100%, 50%)`;
            
            return bColor;
        }

        function animate() {
            sys.textFrame += parseFloat(ui.speed.value);
            sys.borderFrame += parseFloat(ui.borderSpeed.value);

            resize(); 
            drawSourceToBuffer();

            const bufferData = bufCtx.getImageData(0, 0, sys.width, sys.height).data;
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, sys.width, sys.height);

            const brightnessScale = parseInt(ui.bright.value) / 100;
            const shape = ui.shape.value;
            const radius = sys.px / 2;
            const fullUnit = sys.px + sys.gap;
            const isCircle = shape === 'circle';
            const doGlow = brightnessScale > 0.8 && shape !== 'pixel';

            // Draw Inner Grid
            for(let r = 0; r < sys.rows; r++) {
                for(let c = 0; c < sys.cols; c++) {
                    const x = sys.gap + c * fullUnit;
                    const y = sys.gap + r * fullUnit;
                    const centerX = Math.floor(x + radius);
                    const centerY = Math.floor(y + radius);
                    const pixelIndex = (centerY * sys.width + centerX) * 4;
                    const alpha = bufferData[pixelIndex + 3];
                    
                    if(alpha > 50) {
                        const rV = bufferData[pixelIndex];
                        const gV = bufferData[pixelIndex + 1];
                        const bV = bufferData[pixelIndex + 2];
                        ctx.fillStyle = `rgba(${rV},${gV},${bV},${(alpha/255) * brightnessScale})`;
                        if(doGlow) { ctx.shadowBlur = sys.px; ctx.shadowColor = ctx.fillStyle; } else ctx.shadowBlur = 0;
                        if(isCircle) { ctx.beginPath(); ctx.arc(x + radius, y + radius, radius, 0, Math.PI*2); ctx.fill(); }
                        else ctx.fillRect(x, y, sys.px, sys.px);
                    }
                }
            }
            ctx.shadowBlur = 0;

            // --- BORDER DRAWING ---
            const perimeter = 2 * sys.cols + 2 * (sys.rows - 2); 
            let bIdx = 0;
            
            const drawBorderLed = (c, r, color) => {
                const x = sys.gap + c * fullUnit;
                const y = sys.gap + r * fullUnit;
                ctx.fillStyle = color;
                if(isCircle) { ctx.beginPath(); ctx.arc(x+radius, y+radius, radius, 0, Math.PI*2); ctx.fill(); }
                else ctx.fillRect(x, y, sys.px, sys.px);
            };

            if(ui.borderAnim.value !== 'none') {
                for(let c = 0; c < sys.cols; c++) {
                    const col = getBorderColor(bIdx++, perimeter); if(col) drawBorderLed(c, 0, col);
                }
                for(let r = 1; r < sys.rows - 1; r++) {
                    const col = getBorderColor(bIdx++, perimeter); if(col) drawBorderLed(sys.cols-1, r, col);
                }
                for(let c = sys.cols - 1; c >= 0; c--) {
                    const col = getBorderColor(bIdx++, perimeter); if(col) drawBorderLed(c, sys.rows-1, col);
                }
                for(let r = sys.rows - 2; r > 0; r--) {
                    const col = getBorderColor(bIdx++, perimeter); if(col) drawBorderLed(0, r, col);
                }
            }

            requestAnimationFrame(animate);
        }

        document.getElementById('fsBtn').onclick = () => {
            const el = document.getElementById('screen-wrapper');
            if(!document.fullscreenElement) {
                if (el.requestFullscreen) el.requestFullscreen();
                else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
            }
        };

        requestAnimationFrame(animate);
    </script>
</body>
</html>
